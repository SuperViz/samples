/*! For license information please see 324.js.LICENSE.txt */
"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[324],{62576:(t,i,e)=>{e.d(i,{Bl:()=>l,Lm:()=>c,Pi:()=>o,RV:()=>a,e_:()=>r,v6:()=>s});var n=e(19663);class s extends n.m{constructor(){super(),this.id="PLUGIN_RESET_ALL",this.payload={}}}class a extends n.m{constructor(t,i,e){super(),this.id="PLUGIN_RELOAD",this.payload={name:t,config:i,configMeta:e}}}class o extends n.m{constructor(t,i,e){super(),this.id="PLUGIN_LOAD",this.payload={name:t,config:i,configMeta:e}}}class r extends n.m{constructor(t){super(),this.id="PLUGIN_UNLOAD",this.payload={name:t}}}class c extends n.m{constructor(t,i){super(),this.id="PLUGIN_CONFIG_FETCH_DATA",this.payload={operation:t,callback:i}}}class l extends n.m{constructor(t,i){super(),this.id="ATTACHMENT_ASSOCIATE_WITH_PLUGIN",this.payload={attachmentId:t,pluginId:i}}}},14057:(t,i,e)=>{e.r(i),e.d(i,{PluginConfigData:()=>n.i,default:()=>_,getPluginMetadataUrl:()=>f,getPluginUrl:()=>p});var n=e(23748),s=e(97542),a=e(92810),o=e(3907);const r="0.0";function c(t){if(!t)return[];const i={[r]:l}["0.0"];if(!i)throw new Error(`[PluginConfigDeserializer] Data with version "${t.version}": not recognized.`);return i(t)}function l(t){return t["0.0"]}const u="0.0";function d(t){const i={[u]:g};if(!t)throw new Error("[PluginConfigSerializer] no data to serialize.");const e=i["0.0"];if(!e)throw new Error('[PluginConfigSerializer] Version "0.0" not recognized.');return e(t)}function g(t){return{[u]:t}}class h extends o.MU{constructor(t,i,e){super({queue:t,path:`${i}/api/v1/jsonstore/model/plugins/${e}`,batchUpdate:!0,deserialize:c,serialize:d})}}function p(t,i,e){return e+`${t}/${i}/${t}.js`}function f(t,i,e){return e+`${t}/${i}/plugin.json`}const m=t=>{var i,e,n;return null!==(n=null===(e=null===(i=null==t?void 0:t.src)||void 0===i?void 0:i.match(/(\d+\.\d+\.\d+)\/[^\/]*\.js$/))||void 0===e?void 0:e[1])&&void 0!==n?n:null};var y=e(44443),v=e(8807),P=e(7162),b=e(36625),D=e(80742),C=e(62576);const w="unknown-app-key";class _ extends s.Y{constructor(){super(...arguments),this.name="plugin-config",this._registryLoaded=!1}get serviceSdkKey(){if(!this._applicationKey)throw new Error("[PluginConfigData] service key has not yet been set.");return this._applicationKey}get canOverrideStrict(){var t,i;return null===(i=null===(t=this._config)||void 0===t?void 0:t.pluginPolicies)||void 0===i?void 0:i.canDebug}get registryLoaded(){return this._registryLoaded}async init(t,i){this.queue=t.queue,this.pluginConfigData=new n.i,this._config=t;if([this._policyData,this._layersData]=await Promise.all([i.market.waitForData(v.n),i.market.waitForData(D.R)]),t.pluginPolicies.enabled){const e=(await i.getModuleBySymbol(a.Vs)).getApi(),n=await e.getAppKey("showcase","plugin");if(n instanceof Object){const i=n;await this.initializePluginRegistry(i,t),await this.setupConfigStore(t.baseUrl,t.modelId,false),this._registryLoaded=!0}}i.commandBinder.addBinding(C.Bl,(async t=>{var i,e;const n=(await this.pluginConfigData.getMdsResult()).find((i=>i.name===t.pluginId)),s=null!==(e=null===(i=null==n?void 0:n.attachments)||void 0===i?void 0:i.map((t=>t.id)))&&void 0!==e?e:[];this.pluginConfigData.updateMds({name:t.pluginId,attachments:[...s,t.attachmentId]})})),i.market.register(this,n.i,this.pluginConfigData)}async saveToMds(t){var i;if(!this.pluginConfigData.mdsIsSetup)return void this.log.warn("Plugin changes will NOT be saved");const e=null!==(i=m(t))&&void 0!==i?i:"0.0.0";this._manifest.find((t=>t.versions[e]))?this.pluginConfigData.updateMds({name:t.id,version:e}):this.log.warn(`Version ${e} does not exist in registry. Changes not saved to MDS.`)}deleteFromMds(t){this.pluginConfigData.mdsIsSetup?this.pluginConfigData.deleteMdsById(t.id):this.log.warn("Plugin changes will NOT be saved")}saveConfig(t,i){const e=this.pluginConfigData.lastSavedConfiguration.values();this.log.debugInfo(`configuration for ${t.id} updated. ${JSON.stringify(e,void 0,2)}`),t.enabled?this.saveToMds(t):this.deleteFromMds(t),this.currentStore.update(e)}setupConfigStore(t,i,e){this.currentStore=new h(this.queue,t,i),this.pluginConfigData.setupConfigStore(this._layersData.mdsContext,e,t);return this.currentStore.read().then((t=>{t||(t=[]),this.log.debugInfo(`Saved configuration data loaded for ${t.length} plugin(s). ${JSON.stringify(t,void 0,2)}`),this.pluginConfigData.lastSavedConfiguration.replace(t),this.pluginConfigData.lastSavedConfiguration.onElementChanged({onAdded:this.saveConfig.bind(this),onUpdated:this.saveConfig.bind(this),onRemoved:this.deleteFromMds.bind(this)})})).catch((t=>this.log.error("Failed to load configured plugins: ",t)))}getAutoUpgradedVersion(t,i){var e;const n=Object.keys(i.versions).sort(((t,i)=>P.o.compare(i,t))).filter((t=>this.hasRequiredPolicies(i.versions[t].requiredPolicies))),s=null!==(e=b.maxSatisfying(n,`~${t}`))&&void 0!==e?e:t,a=i.currentVersion;let o=s;return b.gt(s,a)&&(o=a),o}dispose(t){super.dispose(t),t.market.unregister(this,n.i),this.pluginConfigData=void 0}async initializePluginRegistry(t,i){const{manifestUrl:e,applicationKey:n}=this.getManifestUrl(t,i);this._applicationKey=n;const s=await this.queue.get(e,{responseType:"json"}).catch((t=>(this.log.error(t),null)));null!==s?(this._manifest=s,await this.populateFromManifest(s,t,n)):this.log.error("Plugin manifest could not be found, please contact support.")}getManifestUrl(t,i,e=!0){let n=t.manifestUrl,s=t.applicationKey;return this.pluginConfigData.manifestUrl&&((0,y.mM)(this.pluginConfigData.manifestUrl)||i.pluginPolicies.canDebug)&&(n=this.pluginConfigData.manifestUrl),n.match(/localhost/)&&e&&(i.pluginPolicies.canDebug||(s=w)),{manifestUrl:n,applicationKey:s}}async populateFromManifest(t,i,e){const n=[];for(const s of t)n.push(this.registerManifestEntry(s,i,e));await Promise.all(n)}async registerManifestEntry(t,i,e){const n=this.findLatestPermittedVersion(t.versions,t.currentVersion);if(!n)return;t.currentVersion=n;const s=Object.assign(Object.assign({},t),{src:t.src||p(t.name,t.currentVersion,i.baseUrl),meta:t.meta||f(t.name,t.currentVersion,i.baseUrl),applicationKey:t.applicationKey||e||w});if(!(0,y.mM)(s.src)||!(0,y.mM)(s.meta))return;const a=await this.queue.get(s.meta,{responseType:"json"}).catch((t=>{this.log.error(t)}));a&&this.pluginConfigData.add({name:s.name,description:a.description,version:s.currentVersion,config:a.config||{},applicationKey:s.applicationKey,src:s.src,meta:s.meta,icon:a.icon,enabled:!1,strict:this.canOverrideStrict&&null!==this.pluginConfigData.strict?this.pluginConfigData.strict:s.sesStrict})}findLatestPermittedVersion(t,i){const e=Object.keys(t).sort(((t,i)=>P.o.compare(i,t)));for(const n of e){const e=t[n].requiredPolicies;if(!P.o.gt(n,i)&&this.hasRequiredPolicies(e))return n}return null}hasRequiredPolicies(t){return!t||0===t.length||t.reduce(((t,i)=>{if(!t)return t;if(i instanceof Object){if("or"===i.operator)return i.policies.some((t=>this._policyData.hasPolicy(t)));if("xor"===i.operator){let t=0;return i.policies.forEach((i=>{t+=this._policyData.hasPolicy(i)?1:0})),1===t}return this.log.warn(`unrecognized required policy entry, operator: <${i.operator}> - plugin disabled`),!1}return this._policyData.hasPolicy(i)}),!0)}async getConfiguredPlugins(){const t=await this.currentStore.read()||[],i=[];return t.forEach((t=>{var e;if(t.enabled){const n=this.pluginConfigData.availablePlugins.get(t.id);let s=!(n&&(!n||void 0!==n.strict))||n.strict;if(!n)return this.log.warn(`"${t.id}" plugin not found in current plugin manifest -- was it configured with a different one?`),void this.log.warn(`Unrecognized plugin disallowed "${null==t?void 0:t.id}" cannot load from ${null==t?void 0:t.src}`);const a={config:t.config||{},src:t.src||n.src,meta:t.meta||n.meta,id:t.id||n.name,strict:s,applicationKey:(null==n?void 0:n.applicationKey)||"FAKE_APP_KEY"};{const t=m(a),i=this._manifest.find((t=>t.name===a.id));if(t&&i){const n=this.getAutoUpgradedVersion(t,i);null!==n&&n!==t&&(this.log.debugInfo(`Replacing ${i.name} version ${t} with version ${n}`),a.src=a.src.replace(t,n),a.meta=null===(e=a.meta)||void 0===e?void 0:e.replace(t,n))}else this.log.debugInfo(`Missing config version or manifest entry for ${a.id}. Not auto-updating patch for this plugin.`)}i.push(a)}})),i}}},3907:(t,i,e)=>{e.d(i,{MU:()=>r});var n,s=e(39880),a=e(44584);!function(t){t.GET="GET",t.POST="POST",t.PATCH="PATCH",t.PUT="PUT",t.DELETE="DELETE",t.OPTIONS="OPTIONS"}(n||(n={}));class o extends class{constructor(){this._options={responseType:"json"}}get options(){const t=this._options;return t.headers=(0,a.m)(this.url,this._options.headers||{}),t}}{constructor(t){super(),this.config=t,this.url=t.path}async read(){const{deserialize:t}=this.config;let i=null;return this.config.cachedData&&this.config.cachedData.data?i=this.config.cachedData.data:(i=await this.config.queue.get(this.config.path,this.options),this.config.cachedData&&(this.config.cachedData.data=i)),t(i)}clearCache(){this.config.cachedData&&(this.config.cachedData.data=null)}}class r extends o{constructor(t){super(t),this.config=t,this.acceptsPartial=!1,this.config.batchUpdate="batchUpdate"in this.config&&this.config.batchUpdate}async create(t){throw Error("Not implemented")}updateBatch(t,i){const{serialize:e}=this.config,s=[],a=[...new Set([...Object.keys(t),...Object.keys(i)])];for(const e of a){t[e]||i[e]||s.push(this.config.queue.delete(`${this.config.path}/${e}`,this.options))}const o=e(t,i),r=Object.assign(Object.assign({},this.options),{body:o});return s.push(this.config.queue.request(this.config.httpMethod||n.POST,this.config.path,r)),Promise.all(s)}updateInternal(t,i){const{serialize:e}=this.config,a=[],o=Object.assign({},this.options),r=Object.keys(t),c=Object.keys(i),l=(0,s.XN)(r.concat(c));for(const s in l){const r=l[s],c=t[r]||i[r];if(c){const t={};t[r]=c;const s={},l=i[r];l&&(s[r]=l);const u=e(t,s);o.body=u,a.push(this.config.queue.request(this.config.httpMethod||n.POST,this.config.path,o))}else a.push(this.config.queue.delete(`${this.config.path}/${r}`,this.options))}return Promise.all(a)}async update(t,i){this.clearCache(),await(this.config.batchUpdate?this.updateBatch(t,i||{}):this.updateInternal(t,i||{}))}async delete(t){throw Error("Not implemented")}}}}]);